module ActsAsReplaceable
  module ActMethod
    # If any before_save methods change the attributes,
    # acts_as_replaceable will not function correctly.
    def acts_as_replaceable(options = {})
      cattr_accessor :acts_as_replaceable_options
      self.acts_as_replaceable_options = options

      self.acts_as_replaceable_options[:match] = Array(self.acts_as_replaceable_options[:match])
      self.acts_as_replaceable_options[:inherit] = Array(self.acts_as_replaceable_options[:inherit]) + [:id]
      self.acts_as_replaceable_options[:ignore] = Array(self.acts_as_replaceable_options[:ignore]) + [:created_at, :updated_at]

      include ActsAsReplaceable::InstanceMethods
    end
  end

  module InstanceMethods
    # Override the create or update method so we can run callbacks, but opt not to save if we don't need to
    def create
      find_and_replace
      if @has_not_changed
        logger.info "(acts_as_replaceable) Found unchanged #{self.class.to_s} ##{id} #{"- Name: #{name}" if respond_to?('name')}"
      elsif @has_been_replaced
        update
        logger.info "(acts_as_replaceable) Updated existing #{self.class.to_s} ##{id} #{"- Name: #{name}" if respond_to?('name')}"
      else
        super
        logger.info "(acts_as_replaceable) Created #{self.class.to_s} ##{id} #{"- Name: #{name}" if respond_to?('name')}"
      end
      
      return true
    end

    def find_and_replace
      replace(find_duplicate(conditions_for_find_duplicate))
    end

    def find_duplicate(conditions = {})
      records = self.class.where(conditions)
      if records.size > 1
        raise "Duplicate Records Present in Database: #{self.class} - #{conditions}"
      end

      return records.first
    end

    def replace(other)
      return unless other
      inherit_attributes(other)
      @has_been_replaced = true
      define_singleton_method(:new_record?) { false }
      define_singleton_method(:persisted?) { true }
      @has_not_changed = !mark_changes(other)
    end

    # Inherit other's attributes for those in acts_as_replaceable_options[:inherit]
    def inherit_attributes(other)
      acts_as_replaceable_options[:inherit].each do |attrib|
        self[attrib] = other[attrib]
      end
    end

    def mark_changes(other)
      attribs = self.attributes

      # Ignore fields that we don't care about changes in
      acts_as_replaceable_options[:ignore].each do |attrib|
        attribs.delete(attrib.to_s)
      end

      # Copy attributes to other and see how it would change if we updated it
      # Mark all self's attributes that have changed, so even if they are
      # still default values, they will be saved to the database
      attribs.each do |key, value|
        # rescue any errors generated by using nested_attributes
        begin; other.send("#{key}=", value); rescue NoMethodError; end
      end
      
      other.changed.each {|attribute| send("#{attribute}_will_change!") }

      return other.changed?
    end

    # Search the incoming attributes for attributes that are in the replaceable conditions and use those to form a conditions hash
    # eg. given acts_as_replaceable :conditions => [:first_name, :last_name]
    #     replacement_conditions({:first_name => 'dave', :last_name => 'bobo', :age => 42}) => :first_name => 'dave', :last_name => 'bobo'
    def conditions_for_find_duplicate
      {}.tap do |output|
        acts_as_replaceable_options[:match].each do |attribute_name|
          output[attribute_name] = self[attribute_name]
        end
      end
    end
  end
end